//----- Variables -----------------------------------------------------------------------------------------------------

alpha = 0
bestPv = 
beta = 0
change = -138
childPv = 5861 
i = 64
idx = 
len = 13
line idx = 47
move = 724793
moves = 
piece = 1
score = 0
tmp = 0
tmp2 = 61
tmp3 = 1
tmp4 = 5
tmp5 = 0
tmp6 = 0
tmp7 = 11
value = 
xtmp = 7
ytmp = 6


//----- Lists ---------------------------------------------------------------------------------------------------------

changes = { 
    853
    1742
    8352
    699
    861
    85
    8379
    672
    9212
    757
    8377
    699
    9084
    697
    8377
    9852
    9084
    697
}
loaded = { }
pieces = { 
    Pw
    Pb
    Nw
    Nb
    Bw
    Bb
    Rw
    Rb
    Qw
    Qb
    Kw
    Kb
}
pointers = { 
    57
    58
    59
    60
    61
    62
    63
    64
    49
    50
    51
    52
    53
    54
    55
    56
    41
    42
    43
    44
    45
    46
    47
    48
    33
    34
    35
    36
    37
    38
    39
    40
    25
    26
    27
    28
    29
    30
    31
    32
    17
    18
    19
    20
    21
    22
    23
    24
    9
    10
    11
    12
    13
    14
    15
    16
    1
    2
    3
    4
    5
    6
    7
    8
}
tmp = { 
    82
    82
    82
    82
    82
    82
    82
    82
    180
    216
    143
    177
    150
    208
    116
    71
    76
    89
    108
    113
    147
    138
    107
    62
    68
    95
    88
    103
    105
    94
    99
    59
    55
    80
    77
    94
    99
    88
    92
    57
    56
    78
    78
    72
    85
    85
    115
    70
    47
    81
    62
    59
    67
    106
    120
    60
    82
    82
    82
    82
    82
    82
    82
    82
    170
    248
    303
    288
    398
    240
    322
    230
    264
    296
    409
    373
    360
    399
    344
    320
    290
    397
    374
    402
    421
    466
    410
    381
    328
    354
    356
    390
    374
    406
    355
    359
    324
    341
    353
    350
    365
    356
    358
    329
    314
    328
    349
    347
    356
    354
    362
    321
    308
    284
    325
    334
    336
    355
    323
    318
    232
    316
    279
    304
    320
    309
    318
    314
    336
    369
    283
    328
    340
    323
    372
    357
    339
    381
    347
    352
    395
    424
    383
    318
    349
    402
    408
    405
    400
    415
    402
    363
    361
    370
    384
    415
    402
    402
    372
    363
    359
    378
    378
    391
    399
    377
    375
    369
    365
    380
    380
    380
    379
    392
    383
    375
    369
    380
    381
    365
    372
    386
    398
    366
    332
    362
    351
    344
    352
    353
    326
    344
    509
    519
    509
    528
    540
    486
    508
    520
    504
    509
    535
    539
    557
    544
    503
    521
    472
    496
    503
    513
    494
    522
    538
    493
    453
    466
    484
    503
    501
    512
    469
    457
    441
    451
    465
    476
    486
    470
    483
    454
    432
    452
    461
    460
    480
    477
    472
    444
    433
    461
    457
    468
    476
    488
    471
    406
    458
    464
    478
    494
    493
    484
    440
    451
    997
    1025
    1054
    1037
    1084
    1069
    1068
    1070
    1001
    986
    1020
    1026
    1009
    1082
    1053
    1079
    1012
    1008
    1032
    1033
    1054
    1081
    1072
    1082
    998
    998
    1009
    1009
    1024
    1042
    1023
    1026
    1016
    999
    1016
    1015
    1023
    1021
    1028
    1022
    1011
    1027
    1014
    1023
    1020
    1027
    1039
    1030
    990
    1017
    1036
    1027
    1033
    1040
    1022
    1026
    1024
    1007
    1016
    1035
    1010
    1000
    994
    975
    -65
    23
    16
    -15
    -56
    -34
    2
    13
    29
    -1
    -20
    -7
    -8
    -4
    -38
    -29
    -9
    24
    2
    -16
    -20
    6
    22
    -22
    -17
    -20
    -12
    -27
    -30
    -25
    -14
    -36
    -49
    -1
    -27
    -39
    -46
    -44
    -33
    -51
    -14
    -14
    -22
    -46
    -44
    -30
    -15
    -27
    1
    7
    -8
    -64
    -43
    -16
    9
    8
    -15
    36
    12
    -54
    8
    -28
    24
    14
}
vals_smootheds = { 
    82
    337
    365
    477
    1025
    0
}
virtual board = { 
    0
    0
    0
    0
    12
    0
    0
    0
    2
    0
    0
    0
    2
    2
    2
    2
    0
    0
    0
    0
    0
    0
    0
    0
    0
    2
    0
    0
    0
    1
    0
    0
    0
    0
    0
    1
    0
    0
    0
    0
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    0
    0
    0
    0
    10
    0
    0
    0
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(AI to play)
{
    Call position to virtual board;
    Call Evaluate PST;
    nodes = 0;
    nps = Sensing.DaysSince2000();
    Call minimax(6)((-1 / ))((1 / ))((turn == "w"))("")("")("")("");
    Call make_move_int(Operator.Join(Operator.LetterOf(childPv, 1), Operator.LetterOf(childPv, 2)))(Operator.Join(Operator.LetterOf(childPv, 3), Operator.LetterOf(childPv, 4)));
    List.Add(moves history, move);
    nps = Operator.Join(Operator.Round(((nodes / ((Sensing.DaysSince2000() - nps) * 86400)) / 1000)), " knps");
    nodes = Operator.Join(nodes, "n");
    List.DeleteAll(moves);
    Call virtual board to position;
}

WhenBroadcastReceived(generate_moves)
{
    Call generate moves(Sensing.Of(idx1, UI//render))(( Or ))(((turn == "w") + ));
}

WhenBroadcastReceived(init)
{
    List.DeleteAll(moves history);
    List.DeleteAll(changes);
    Call init lists;
}

WhenBroadcastReceived(init 2)
{
    Call smooth tables(0);
    Call Evaluate PST;
}

WhenBroadcastReceived(load into virtual board)
{
    Call position to virtual board;
}

WhenBroadcastReceived(UI make move)
{
    Call position to virtual board;
    Call make_move_int(Sensing.Of(idx1, UI//render))(Sensing.Of(idx2, UI//render));
    List.Add(moves history, move);
    Call virtual board to position;
}

WhenBroadcastReceived(UI undo)
{
    Call position to virtual board;
    Call unmake move(moves history[List.Length(moves history)]);
    List.DeleteItem(moves history, List.Length(moves history));
    Call virtual board to position;
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define add change(string idx) piece old(string old) new piece(string new) (warp=true)
{
    List.Add(changes, (((idx - 1) + (old * 64)) + (832 * new)));
}

Define add move(string idx)(string idx2) (warp=true)
{
    List.Add(moves, Operator.Join(Operator.Join(Operator.LetterOf(0, (2 > Variable.Length(idx))), idx), Operator.Join(Operator.LetterOf(0, (2 > Variable.Length(idx2))), idx2)));
    If ((virtual board[idx] % 2) == 0)
    {
        If (Attack table b[idx] < 9)
        {
            List.ReplaceItem(Attack table b, idx, (Attack table b[idx] + 1));
        }
    }
    Else
    {
        If (Attack table w[idx] < 9)
        {
            List.ReplaceItem(Attack table w, idx, (Attack table w[idx] + 1));
        }
    }
}

Define check and add move(string idx)(string offx)(string offy)(bool only capture?)(bool only not capture?)(bool promotions?) (warp=true)
{
    ytmp = ceiling((idx / 8));
    xtmp = (((idx - 1) % 8) + 1);
    xtmp += offx;
    ytmp += offy;
    If ((xtmp < 1) Or (ytmp < 1))
    {
        Stop(this script);
    }
    If ((xtmp > 8) Or (ytmp > 8))
    {
        Stop(this script);
    }
    line idx = ((ytmp * 8) + (xtmp - 8));
    If (virtual board[line idx] > 0)
    {
        If ((virtual board[line idx] % 2) == (1 - (virtual board[idx] % 2)))
        {
            If (Not (only not capture?))
            {
                If (promotions? And Operator.Contains(18, ytmp))
                {
                    Call add move(idx)(Operator.Join(xtmp, "Q"));
                    Call add move(idx)(Operator.Join(xtmp, "B"));
                    Call add move(idx)(Operator.Join(xtmp, "N"));
                    Call add move(idx)(Operator.Join(xtmp, "R"));
                }
                Else
                {
                    Call add move(idx)(line idx);
                }
            }
        }
        Stop(this script);
    }
    If (Not (only capture?))
    {
        If (promotions? And Operator.Contains(18, ytmp))
        {
            Call add move(idx)(Operator.Join(xtmp, "Q"));
            Call add move(idx)(Operator.Join(xtmp, "B"));
            Call add move(idx)(Operator.Join(xtmp, "N"));
            Call add move(idx)(Operator.Join(xtmp, "R"));
        }
        Else
        {
            Call add move(idx)(line idx);
        }
    }
}

Define encode move(string start)(string end)(string promotion)(string is_capture)(string captured_piece)(string castle_type)(string en_passant)(string en_passant_val)(string half_moves) (warp=true)
{
    move = (start - 1);
    move += (64 * (end - 1));
    move += (4096 * promotion);
    move += (65536 * is_capture);
    move += (131072 * captured_piece);
    move += (1048576 * castle_type);
    move += (5242880 * en_passant);
    move += (10485760 * en_passant_val);
    move += (681574400 * half_moves);
    move += (68157440000 * o-o b);
    move += (136314880000 * o-o w);
    move += (272629760000 * o-o-o b);
    move += (545259520000 * o-o-o w);
}

Define Evaluate PST (warp=true)
{
    PST eval = 0;
    i = 0;
    Repeat (64)
    {
        i += 1;
        PST eval += tables[((virtual board[i] * 64) + (i - 64))];
    }
    List.DeleteAll(changes);
}

Define Evaluate PST (fast) (warp=true)
{
    Repeat (List.Length(changes))
    {
        Call get eval PST change(((changes[1] % 64) + 1))((floor((changes[1] / 64)) % 13))((floor((changes[1] / 832)) % 13));
        PST eval += change;
        List.DeleteItem(changes, 1);
    }
}

Define generate all move(bool is maximizing?)(bool only captures?) (warp=true)
{
    List.DeleteAll(moves);
    List.DeleteAll(Attack table b);
    List.DeleteAll(Attack table w);
    Repeat (64)
    {
        List.Add(Attack table w, 0);
        List.Add(Attack table b, 0);
    }
    i2 = 0;
    Repeat (64)
    {
        i2 += 1;
        If (virtual board[i2] > 0)
        {
            If ((virtual board[i2] % 2) == is maximizing?)
            {
                Call generate moves(i2)(only captures?)(is maximizing?);
            }
        }
    }
}

Define generate line(string idx)(string offx)(string offy)(bool only captures?)(string color) (warp=true)
{
    ytmp = ceiling((idx / 8));
    xtmp = (((idx - 1) % 8) + 1);
    Repeat (8)
    {
        xtmp += offx;
        ytmp += offy;
        If ((xtmp < 1) Or (ytmp < 1))
        {
            Stop(this script);
        }
        If ((xtmp > 8) Or (ytmp > 8))
        {
            Stop(this script);
        }
        line idx = ((ytmp * 8) + (xtmp - 8));
        If (virtual board[line idx] > 0)
        {
            If ((virtual board[line idx] % 2) == (1 - color))
            {
                Call add move(idx)(line idx);
            }
            Stop(this script);
        }
        If (Not (only captures?))
        {
            Call add move(idx)(line idx);
        }
    }
}

Define generate moves(string idx)(bool only captures?)(string color (bin)) (warp=true)
{
    piece = virtual board[idx];
    If (piece > 0)
    {
        If ((piece < 11) And (piece > 4))
        {
            If (piece > 6)
            {
                Call generate line(idx)(0)(1)(only captures?)(color (bin));
                Call generate line(idx)(1)(0)(only captures?)(color (bin));
                Call generate line(idx)(0)(-1)(only captures?)(color (bin));
                Call generate line(idx)(-1)(0)(only captures?)(color (bin));
            }
            If ((piece < 7) Or (piece > 8))
            {
                Call generate line(idx)(1)(1)(only captures?)(color (bin));
                Call generate line(idx)(1)(-1)(only captures?)(color (bin));
                Call generate line(idx)(-1)(1)(only captures?)(color (bin));
                Call generate line(idx)(-1)(-1)(only captures?)(color (bin));
            }
        }
        Else
        {
            If (piece < 3)
            {
                If (piece == 1)
                {
                    len = List.Length(moves);
                    Call check and add move(idx)(0)(-1)(only captures?)((Not ()))((Not ()));
                    If (ceiling((idx / 8)) == 7)
                    {
                        If (List.Length(moves) > len)
                        {
                            Call check and add move(idx)(0)(-2)(only captures?)((Not ()))(( Or ));
                        }
                    }
                    Call check and add move(idx)(1)(-1)((Not ()))(( Or ))((Not ()));
                    Call check and add move(idx)(-1)(-1)((Not ()))(( Or ))((Not ()));
                    If (abs((en passant - idx)) == 1)
                    {
                        If (ceiling((idx / 8)) == 4)
                        {
                            If ((((idx - 1) % 8) + 1) > 1)
                            {
                                If (en passant == (idx - 1))
                                {
                                    Call check and add move(idx)(-1)(-1)(( Or ))(( Or ))(( Or ));
                                }
                            }
                        }
                        If ((((idx - 1) % 8) + 1) < 8)
                        {
                            If (en passant == (idx + 1))
                            {
                                Call check and add move(idx)(1)(-1)(( Or ))(( Or ))(( Or ));
                            }
                        }
                    }
                }
                Else
                {
                    len = List.Length(moves);
                    Call check and add move(idx)(0)(1)(only captures?)((Not ()))((Not ()));
                    If (ceiling((idx / 8)) == 2)
                    {
                        If (List.Length(moves) > len)
                        {
                            Call check and add move(idx)(0)(2)(only captures?)((Not ()))(( Or ));
                        }
                    }
                    Call check and add move(idx)(1)(1)((Not ()))(( Or ))((Not ()));
                    Call check and add move(idx)(-1)(1)((Not ()))(( Or ))((Not ()));
                    If (abs((en passant - idx)) == 1)
                    {
                        If (ceiling((idx / 8)) == 5)
                        {
                            If ((((idx - 1) % 8) + 1) > 1)
                            {
                                If (en passant == (idx - 1))
                                {
                                    Call check and add move(idx)(-1)(1)(( Or ))(( Or ))(( Or ));
                                }
                            }
                        }
                        If ((((idx - 1) % 8) + 1) < 8)
                        {
                            If (en passant == (idx + 1))
                            {
                                Call check and add move(idx)(1)(1)(( Or ))(( Or ))(( Or ));
                            }
                        }
                    }
                }
            }
            Else
            {
                If (piece < 5)
                {
                    Call check and add move(idx)(2)(1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(1)(2)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(-2)(1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(-1)(2)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(2)(-1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(1)(-2)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(-2)(-1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(-1)(-2)(only captures?)(( Or ))(( Or ));
                }
                Else
                {
                    Call check and add move(idx)(1)(1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(0)(1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(-1)(1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(1)(-1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(0)(-1)(only captures?)(( Or ))(( Or ));
                    Call check and add move(idx)(-1)(-1)(only captures?)(( Or ))(( Or ));
                    len = List.Length(moves);
                    Call check and add move(idx)(1)(0)(only captures?)(( Or ))(( Or ));
                    If (piece == 11)
                    {
                        If (List.Length(moves) > len)
                        {
                            If (((virtual board[61] == 11) And (((virtual board[(idx + 1)] == 0) And (o-o w == 1)) And (virtual board[(idx + 2)] == 0))) And (virtual board[64] == 7))
                            {
                                Call check and add move(idx)(2)(0)(only captures?)(( Or ))(( Or ));
                            }
                        }
                        len = List.Length(moves);
                        Call check and add move(idx)(-1)(0)(only captures?)(( Or ))(( Or ));
                        If (List.Length(moves) > len)
                        {
                            If ((virtual board[61] == 11) And ((((virtual board[(idx - 1)] == 0) And (o-o-o w == 1)) And ((virtual board[(idx - 2)] == 0) And (virtual board[(idx - 3)] == 0))) And (virtual board[57] == 7)))
                            {
                                Call check and add move(idx)(-2)(0)(only captures?)(( Or ))(( Or ));
                            }
                        }
                    }
                    Else
                    {
                        If (List.Length(moves) > len)
                        {
                            If (((virtual board[5] == 12) And (((virtual board[(idx + 1)] == 0) And (o-o b == 1)) And (virtual board[(idx + 2)] == 0))) And (virtual board[8] == 8))
                            {
                                Call check and add move(idx)(2)(0)(only captures?)(( Or ))(( Or ));
                            }
                        }
                        len = List.Length(moves);
                        Call check and add move(idx)(-1)(0)(only captures?)(( Or ))(( Or ));
                        If (List.Length(moves) > len)
                        {
                            If ((virtual board[5] == 12) And ((((virtual board[(idx - 1)] == 0) And (o-o-o b == 1)) And ((virtual board[(idx - 2)] == 0) And (virtual board[(idx - 3)] == 0))) And (virtual board[1] == 8)))
                            {
                                Call check and add move(idx)(-2)(0)(only captures?)(( Or ))(( Or ));
                            }
                        }
                    }
                }
            }
        }
    }
}

Define get eval PST change(string idx)(string old)(string new) (warp=true)
{
    If (new == 0)
    {
        If (old == 0)
        {
            change = 0;
        }
        Else
        {
            change = ( - tables[((old * 64) + (idx - 64))]);
        }
    }
    Else
    {
        If (old == 0)
        {
            change = tables[((new * 64) + (idx - 64))];
        }
        Else
        {
            If (old == new)
            {
                change = 0;
            }
            Else
            {
                change = (tables[((new * 64) + (idx - 64))] - tables[((old * 64) + (idx - 64))]);
            }
        }
    }
}

Define init lists (warp=true)
{
    List.DeleteAll(vals_mg);
    Call Load list cpp("{ 82, 337, 365, 477, 1025,  0}");
    Repeat (List.Length(loaded))
    {
        List.Add(vals_mg, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    List.DeleteAll(vals_eg);
    Call Load list cpp("{ 94, 281, 297, 512,  936,  0}");
    Repeat (List.Length(loaded))
    {
        List.Add(vals_eg, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    List.DeleteAll(mg_vals_PST);
    List.DeleteAll(eg_vals_PST);
    Call Load list cpp("{       0,   0,   0,   0,   0,   0,  0,   0,      98, 134,  61,  95,  68, 126, 34, -11,      -6,   7,  26,  31,  65,  56, 25, -20,     -14,  13,   6,  21,  23,  12, 17, -23,     -27,  -2,  -5,  12,  17,   6, 10, -25,     -26,  -4,  -4, -10,   3,   3, 33, -12,     -35,  -1, -20, -23, -15,  24, 38, -22,       0,   0,   0,   0,   0,   0,  0,   0, }");
    Repeat (List.Length(loaded))
    {
        List.Add(mg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{       0,   0,   0,   0,   0,   0,   0,   0,     178, 173, 158, 134, 147, 132, 165, 187,      94, 100,  85,  67,  56,  53,  82,  84,      32,  24,  13,   5,  -2,   4,  17,  17,      13,   9,  -3,  -7,  -7,  -8,   3,  -1,       4,   7,  -6,   1,   0,  -5,  -1,  -8,      13,   8,   8,  10,  13,   0,   2,  -7,       0,   0,   0,   0,   0,   0,   0,   0, }");
    Repeat (List.Length(loaded))
    {
        List.Add(eg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -167, -89, -34, -49,  61, -97, -15, -107,      -73, -41,  72,  36,  23,  62,   7,  -17,      -47,  60,  37,  65,  84, 129,  73,   44,       -9,  17,  19,  53,  37,  69,  18,   22,      -13,   4,  16,  13,  28,  19,  21,   -8,      -23,  -9,  12,  10,  19,  17,  25,  -16,      -29, -53, -12,  -3,  -1,  18, -14,  -19,     -105, -21, -58, -33, -17, -28, -19,  -23, }");
    Repeat (List.Length(loaded))
    {
        List.Add(mg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -58, -38, -13, -28, -31, -27, -63, -99,     -25,  -8, -25,  -2,  -9, -25, -24, -52,     -24, -20,  10,   9,  -1,  -9, -19, -41,     -17,   3,  22,  22,  22,  11,   8, -18,     -18,  -6,  16,  25,  16,  17,   4, -18,     -23,  -3,  -1,  15,  10,  -3, -20, -22,     -42, -20, -10,  -5,  -2, -20, -23, -44,     -29, -51, -23, -15, -22, -18, -50, -64, }");
    Repeat (List.Length(loaded))
    {
        List.Add(eg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -29,   4, -82, -37, -25, -42,   7,  -8,     -26,  16, -18, -13,  30,  59,  18, -47,     -16,  37,  43,  40,  35,  50,  37,  -2,      -4,   5,  19,  50,  37,  37,   7,  -2,      -6,  13,  13,  26,  34,  12,  10,   4,       0,  15,  15,  15,  14,  27,  18,  10,       4,  15,  16,   0,   7,  21,  33,   1,     -33,  -3, -14, -21, -13, -12, -39, -21, }");
    Repeat (List.Length(loaded))
    {
        List.Add(mg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -14, -21, -11,  -8, -7,  -9, -17, -24,      -8,  -4,   7, -12, -3, -13,  -4, -14,       2,  -8,   0,  -1, -2,   6,   0,   4,      -3,   9,  12,   9, 14,  10,   3,   2,      -6,   3,  13,  19,  7,  10,  -3,  -9,     -12,  -3,   8,  10, 13,   3,  -7, -15,     -14, -18,  -7,  -1,  4,  -9, -15, -27,     -23,  -9, -23,  -5, -9, -16,  -5, -17, }");
    Repeat (List.Length(loaded))
    {
        List.Add(eg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{      32,  42,  32,  51, 63,  9,  31,  43,      27,  32,  58,  62, 80, 67,  26,  44,      -5,  19,  26,  36, 17, 45,  61,  16,     -24, -11,   7,  26, 24, 35,  -8, -20,     -36, -26, -12,  -1,  9, -7,   6, -23,     -45, -25, -16, -17,  3,  0,  -5, -33,     -44, -16, -20,  -9, -1, 11,  -6, -71,     -19, -13,   1,  17, 16,  7, -37, -26, }");
    Repeat (List.Length(loaded))
    {
        List.Add(mg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     13, 10, 18, 15, 12,  12,   8,   5,     11, 13, 13, 11, -3,   3,   8,   3,      7,  7,  7,  5,  4,  -3,  -5,  -3,      4,  3, 13,  1,  2,   1,  -1,   2,      3,  5,  8,  4, -5,  -6,  -8, -11,     -4,  0, -5, -1, -7, -12,  -8, -16,     -6, -6,  0,  2, -9,  -9, -11,  -3,     -9,  2,  3, -1, -5, -13,   4, -20, }");
    Repeat (List.Length(loaded))
    {
        List.Add(eg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -28,   0,  29,  12,  59,  44,  43,  45,     -24, -39,  -5,   1, -16,  57,  28,  54,     -13, -17,   7,   8,  29,  56,  47,  57,     -27, -27, -16, -16,  -1,  17,  -2,   1,      -9, -26,  -9, -10,  -2,  -4,   3,  -3,     -14,   2, -11,  -2,  -5,   2,  14,   5,     -35,  -8,  11,   2,   8,  15,  -3,   1,      -1, -18,  -9,  10, -15, -25, -31, -50, }");
    Repeat (List.Length(loaded))
    {
        List.Add(mg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{      -9,  22,  22,  27,  27,  19,  10,  20,     -17,  20,  32,  41,  58,  25,  30,   0,     -20,   6,   9,  49,  47,  35,  19,   9,       3,  22,  24,  45,  57,  40,  57,  36,     -18,  28,  19,  47,  31,  34,  39,  23,     -16, -27,  15,   6,   9,  17,  10,   5,     -22, -23, -30, -16, -16, -23, -36, -32,     -33, -28, -22, -43,  -5, -32, -20, -41, }");
    Repeat (List.Length(loaded))
    {
        List.Add(eg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -65,  23,  16, -15, -56, -34,   2,  13,      29,  -1, -20,  -7,  -8,  -4, -38, -29,      -9,  24,   2, -16, -20,   6,  22, -22,     -17, -20, -12, -27, -30, -25, -14, -36,     -49,  -1, -27, -39, -46, -44, -33, -51,     -14, -14, -22, -46, -44, -30, -15, -27,       1,   7,  -8, -64, -43, -16,   9,   8,     -15,  36,  12, -54,   8, -28,  24,  14, }");
    Repeat (List.Length(loaded))
    {
        List.Add(mg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
    Call Load list cpp("{     -74, -35, -18, -18, -11,  15,   4, -17,     -12,  17,  14,  17,  17,  38,  23,  11,      10,  17,  23,  15,  20,  45,  44,  13,      -8,  22,  24,  27,  26,  33,  26,   3,     -18,  -4,  21,  24,  27,  23,   9, -11,     -19,  -3,  11,  21,  23,  16,   7,  -9,     -27, -11,   4,  13,  14,   4,  -5, -17,     -53, -34, -21, -11, -28, -14, -24, -43, }");
    Repeat (List.Length(loaded))
    {
        List.Add(eg_vals_PST, loaded[1]);
        List.DeleteItem(loaded, 1);
    }
}

Define Load list cpp(string data) (warp=true)
{
    List.DeleteAll(loaded);
    i = 1;
    List.Add(loaded, "");
    Repeat ((Variable.Length(data) - 2))
    {
        i += 1;
        If (Operator.LetterOf(data, i) == ",")
        {
            List.Add(loaded, "");
        }
        Else
        {
            If (Not ((Operator.LetterOf(data, i) == " ")))
            {
                List.ReplaceItem(loaded, List.Length(loaded), Operator.Join(loaded[List.Length(loaded)], Operator.LetterOf(data, i)));
            }
        }
    }
    If ("" == loaded[List.Length(loaded)])
    {
        List.DeleteItem(loaded, List.Length(loaded));
    }
}

Define LOG(string data)(string type) (warp=true)
{
    List.Add(LOG, data);
}

Define make_move_int(string start)(string end) (warp=true)
{
    If (turn == "b")
    {
        fullmoves += 1;
    }
    halfmoves += 1;
    turn = Operator.LetterOf("wb", ((turn == "w") + 1));
    If ((virtual board[start] < 3) And (Not (((end + ) == end))))
    {
        tmp = ((List.IndexOf(pieces, Operator.Join(Operator.LetterOf(end, 2), "b")) / 2) - 1);
        tmp2 = (Operator.LetterOf(end, 1) + ((19 < start) * 56));
        halfmoves = 0;
    }
    Else
    {
        tmp = 0;
        tmp2 = end;
    }
    If (virtual board[tmp2] > 0)
    {
        tmp3 = 1;
        tmp4 = (ceiling((virtual board[tmp2] / 2)) - 1);
    }
    Else
    {
        tmp3 = 0;
        tmp4 = 0;
    }
    tmp5 = 0;
    If (tmp == 0)
    {
        If (tmp3 == 0)
        {
            If (virtual board[start] > 10)
            {
                If (abs((start - end)) == 2)
                {
                    If (start < end)
                    {
                        If (start < 33)
                        {
                            tmp5 = 1;
                        }
                        Else
                        {
                            tmp5 = 2;
                        }
                    }
                    Else
                    {
                        If (start < 33)
                        {
                            tmp5 = 3;
                        }
                        Else
                        {
                            tmp5 = 4;
                        }
                    }
                }
            }
        }
    }
    tmp6 = 0;
    If 
    {
        If (((start - end) % 8) > 0)
        {
            If (virtual board[end] > 0)
            {
                tmp6 = 1;
            }
        }
    }
    If ((tmp3 == 1) Or ((tmp5 > 0) Or (tmp > 0)))
    {
        halfmoves = 0;
    }
    Call encode move(start)(tmp2)(tmp)(tmp3)(tmp4)(tmp5)(tmp6)(en passant)(halfmoves);
    If (start == 5)
    {
        o-o b = 0;
        o-o-o b = 0;
    }
    Else
    {
        If (start == 61)
        {
            o-o w = 0;
            o-o-o w = 0;
        }
        Else
        {
            If ((start == 1) Or (end == 1))
            {
                o-o-o b = 0;
            }
            Else
            {
                If ((start == 8) Or (end == 8))
                {
                    o-o b = 0;
                }
                Else
                {
                    If ((start == 57) Or (end == 57))
                    {
                        o-o-o w = 0;
                    }
                    Else
                    {
                        If ((start == 64) Or (end == 64))
                        {
                            o-o w = 0;
                        }
                        Else
                        {
                            If Operator.Contains("_8q_8n_8b_8r_1q_1n_1b_1r_", Operator.Join("_", Operator.Join(end, "_")))
                            {
                                If (start < 32)
                                {
                                    If (Operator.LetterOf(end, 1) == 1)
                                    {
                                        o-o-o b = 0;
                                    }
                                    Else
                                    {
                                        o-o b = 0;
                                    }
                                }
                                Else
                                {
                                    If (Operator.LetterOf(end, 1) == 1)
                                    {
                                        o-o-o w = 0;
                                    }
                                    Else
                                    {
                                        o-o w = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    Call add change(tmp2) piece old(virtual board[tmp2]) new piece(virtual board[start]);
    Call add change(start) piece old(virtual board[start]) new piece(0);
    List.ReplaceItem(virtual board, tmp2, virtual board[start]);
    List.ReplaceItem(virtual board, start, 0);
    If ((virtual board[tmp2] < 0) And (virtual board[tmp2] < 3))
    {
        If (abs((start - end)) == 16)
        {
            en passant = end;
        }
        Else
        {
            If (((start - end) % 8) > 0)
            {
                If (virtual board[end] == 1)
                {
                    If (abs((en passant - start)) == 1)
                    {
                        Call add change(en passant) piece old(virtual board[en passant]) new piece(0);
                        List.ReplaceItem(virtual board, en passant, 0);
                    }
                }
                Else
                {
                    If (abs((en passant - start)) == 1)
                    {
                        Call add change(en passant) piece old(virtual board[en passant]) new piece(0);
                        List.ReplaceItem(virtual board, en passant, 0);
                    }
                }
            }
        }
    }
    If (tmp5 > 0)
    {
        If (tmp5 < 3)
        {
            If (tmp5 < 2)
            {
                Call add change(6) piece old(0) new piece(8);
                Call add change(8) piece old(8) new piece(0);
                List.ReplaceItem(virtual board, 6, 8);
                List.ReplaceItem(virtual board, 8, 0);
            }
            Else
            {
                Call add change(62) piece old(0) new piece(7);
                Call add change(64) piece old(7) new piece(0);
                List.ReplaceItem(virtual board, 62, 7);
                List.ReplaceItem(virtual board, 64, 0);
            }
        }
        Else
        {
            If (tmp5 < 4)
            {
                Call add change(1) piece old(8) new piece(0);
                Call add change(4) piece old(0) new piece(8);
                List.ReplaceItem(virtual board, 1, 0);
                List.ReplaceItem(virtual board, 4, 8);
            }
            Else
            {
                Call add change(57) piece old(7) new piece(0);
                Call add change(60) piece old(0) new piece(7);
                List.ReplaceItem(virtual board, 57, 0);
                List.ReplaceItem(virtual board, 60, 7);
            }
        }
        Stop(this script);
    }
    If (tmp > 0)
    {
        tmp7 = (((tmp + 1) * 2) - (virtual board[tmp2] == 1));
        Call add change(tmp2) piece old(virtual board[tmp2]) new piece(tmp7);
        List.ReplaceItem(virtual board, tmp2, tmp7);
    }
}

Define minimax(string depth)(string alpha)(string beta)(bool isWhite)(string moves)(string idx)(string value)(string bestPV) (warp=true)
{
    If (depth == 0)
    {
        Call Evaluate PST (fast);
        score = PST eval;
        childPv = "";
        Stop(this script);
    }
    If isWhite
    {
        If (Not (Operator.Contains(virtual board, 11)))
        {
            score = (-1 / );
            childPv = "";
            Stop(this script);
        }
    }
    Else
    {
        If (Not (Operator.Contains(virtual board, 12)))
        {
            score = (1 / );
            childPv = "";
            Stop(this script);
        }
    }
    alpha = alpha;
    beta = beta;
    Call generate all move(isWhite)(( Or ));
    idx = 0;
    moves = moves;
    bestPv = "";
    If isWhite
    {
        value = (-1 / );
        Repeat (List.Length(moves))
        {
            nodes += 1;
            Call make_move_int(Operator.Join(Operator.LetterOf(moves, (idx + 1)), Operator.LetterOf(moves, (idx + 2))))(Operator.Join(Operator.LetterOf(moves, (idx + 3)), Operator.LetterOf(moves, (idx + 4))));
            List.Add(moves history, move);
            Call minimax((depth - 1))(alpha)(beta)((Not (isWhite)))(moves)(idx)(value)(bestPv);
            Call unmake move(moves history[List.Length(moves history)]);
            List.DeleteItem(moves history, List.Length(moves history));
            If (score > value)
            {
                value = score;
                bestPv = Operator.Join(Operator.Join(Operator.Join(Operator.LetterOf(moves, (idx + 1)), Operator.LetterOf(moves, (idx + 2))), Operator.Join(Operator.LetterOf(moves, (idx + 3)), Operator.LetterOf(moves, (idx + 4)))), Operator.Join(" ", childPv));
            }
            If (alpha < value)
            {
                alpha = value;
            }
            If (Not ((alpha < beta)))
            {
                score = value;
                childPv = bestPv;
                alpha = alpha;
                beta = beta;
                value = value;
                bestPv = bestPV;
                moves = moves;
                idx = idx;
                Stop(this script);
            }
            idx += 5;
        }
    }
    Else
    {
        value = (1 / );
        Repeat (List.Length(moves))
        {
            nodes += 1;
            Call make_move_int(Operator.Join(Operator.LetterOf(moves, (idx + 1)), Operator.LetterOf(moves, (idx + 2))))(Operator.Join(Operator.LetterOf(moves, (idx + 3)), Operator.LetterOf(moves, (idx + 4))));
            List.Add(moves history, move);
            Call minimax((depth - 1))(alpha)(beta)((Not (isWhite)))(moves)(idx)(value)(bestPv);
            Call unmake move(moves history[List.Length(moves history)]);
            List.DeleteItem(moves history, List.Length(moves history));
            If (score < value)
            {
                value = score;
                bestPv = Operator.Join(Operator.Join(Operator.Join(Operator.LetterOf(moves, (idx + 1)), Operator.LetterOf(moves, (idx + 2))), Operator.Join(Operator.LetterOf(moves, (idx + 3)), Operator.LetterOf(moves, (idx + 4)))), Operator.Join(" ", childPv));
            }
            If (beta > value)
            {
                beta = value;
            }
            If (Not ((alpha < beta)))
            {
                score = value;
                childPv = bestPv;
                alpha = alpha;
                beta = beta;
                value = value;
                bestPv = bestPV;
                moves = moves;
                idx = idx;
                Stop(this script);
            }
            idx += 5;
        }
    }
    If Operator.Contains(value, "infinity")
    {
        If Operator.Contains(value, "-")
        {
            value = (-1000000 + depth);
        }
        Else
        {
            value = (1000000 - depth);
        }
    }
    score = value;
    childPv = bestPv;
    alpha = alpha;
    beta = beta;
    value = value;
    bestPv = bestPV;
    moves = moves;
    idx = idx;
}

Define position to virtual board (warp=true)
{
    List.DeleteAll(virtual board);
    Repeat (64)
    {
        List.Add(virtual board, List.IndexOf(pieces, position[(List.Length(virtual board) + 1)]));
    }
}

Define smooth tables(string value) (warp=true)
{
    List.DeleteAll(vals_smootheds);
    Repeat (6)
    {
        List.Add(vals_smootheds, ((vals_mg[(List.Length(vals_smootheds) + 1)] * (1 - value)) + (vals_eg[(List.Length(vals_smootheds) + 1)] * value)));
    }
    List.DeleteAll(tmp);
    i = 0;
    Repeat (List.Length(eg_vals_PST))
    {
        i += 1;
        List.Add(tmp, (((mg_vals_PST[i] * (1 - value)) + (eg_vals_PST[i] * value)) + vals_smootheds[ceiling((i / 64))]));
    }
    List.DeleteAll(tables);
    i = 0;
    Repeat (6)
    {
        Repeat (64)
        {
            i += 1;
            List.Add(tables, tmp[i]);
        }
        i += -64;
        Repeat (64)
        {
            i += 1;
            List.Add(tables, ( - tmp[(pointers[(((i - 1) % 64) + 1)] + ((ceiling((i / 64)) - 1) * 64))]));
        }
    }
}

Define unmake move(string move) (warp=true)
{
    If (turn == "w")
    {
        fullmoves += -1;
    }
    o-o b = (floor((move / 68157440000)) % 2);
    o-o w = (floor((move / 136314880000)) % 2);
    o-o-o b = (floor((move / 272629760000)) % 2);
    o-o-o w = (floor((move / 545259520000)) % 2);
    halfmoves = (floor((move / 681574400)) % 100);
    turn = Operator.LetterOf("wb", ((turn == "w") + 1));
    en passant = (floor((move / 10485760)) % 65);
    tmp = ((move % 64) + 1);
    tmp2 = ((floor((move / 64)) % 64) + 1);
    Call add change(tmp) piece old(virtual board[tmp]) new piece(virtual board[tmp2]);
    List.ReplaceItem(virtual board, tmp, virtual board[tmp2]);
    If ((floor((move / 5242880)) % 2) == 1)
    {
        Call add change(tmp2) piece old(virtual board[tmp2]) new piece(0);
        List.ReplaceItem(virtual board, tmp2, 0);
        If (virtual board[tmp] == 1)
        {
            Call add change((tmp2 + 8)) piece old(virtual board[(tmp2 + 8)]) new piece(2);
            List.ReplaceItem(virtual board, (tmp2 + 8), 2);
        }
        Else
        {
            Call add change((tmp2 - 8)) piece old(virtual board[(tmp2 - 8)]) new piece(1);
            List.ReplaceItem(virtual board, (tmp2 - 8), 1);
        }
        Stop(this script);
    }
    If ((floor((move / 65536)) % 2) == 1)
    {
        tmp7 = ((((floor((move / 131072)) % 8) + 1) * 2) - ((virtual board[tmp2] % 2) == 0));
        Call add change(tmp2) piece old(virtual board[tmp2]) new piece(tmp7);
        List.ReplaceItem(virtual board, tmp2, tmp7);
    }
    Else
    {
        Call add change(tmp2) piece old(virtual board[tmp2]) new piece(0);
        List.ReplaceItem(virtual board, tmp2, 0);
    }
    tmp3 = (floor((move / 4096)) % 16);
    If (tmp3 > 0)
    {
        tmp7 = (2 - (tmp < 32));
        Call add change(tmp) piece old(virtual board[tmp]) new piece(tmp7);
        List.ReplaceItem(virtual board, tmp, tmp7);
        Stop(this script);
    }
    tmp3 = (floor((move / 1048576)) % 5);
    If (tmp3 > 0)
    {
        If (tmp3 < 3)
        {
            If (tmp3 < 2)
            {
                Call add change(6) piece old(8) new piece(0);
                Call add change(8) piece old(0) new piece(8);
                List.ReplaceItem(virtual board, 6, 0);
                List.ReplaceItem(virtual board, 8, 8);
            }
            Else
            {
                Call add change(62) piece old(7) new piece(0);
                Call add change(64) piece old(0) new piece(7);
                List.ReplaceItem(virtual board, 62, 0);
                List.ReplaceItem(virtual board, 64, 7);
            }
        }
        Else
        {
            If (tmp3 < 4)
            {
                Call add change(1) piece old(0) new piece(8);
                Call add change(4) piece old(8) new piece(0);
                List.ReplaceItem(virtual board, 1, 8);
                List.ReplaceItem(virtual board, 4, 0);
            }
            Else
            {
                Call add change(57) piece old(0) new piece(7);
                Call add change(60) piece old(7) new piece(0);
                List.ReplaceItem(virtual board, 57, 7);
                List.ReplaceItem(virtual board, 60, 0);
            }
        }
    }
}

Define virtual board to position (warp=true)
{
    List.DeleteAll(position);
    Repeat (64)
    {
        List.Add(position, pieces[virtual board[(List.Length(position) + 1)]]);
        If (position[List.Length(position)] == "")
        {
            List.ReplaceItem(position, List.Length(position), 00);
        }
    }
}


//----- Costumes ------------------------------------------------------------------------------------------------------

.svg
